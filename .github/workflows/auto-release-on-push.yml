name: Auto Release on Push

on:
  push:
    branches: [ main ]
    paths-ignore:
      - 'README.md'
      - 'docs/**'
      - '*.md'

permissions:
  contents: write        # Needed to create releases and push tags
  actions: read         # Needed to read workflow artifacts
  packages: write       # Needed for package publishing
  id-token: write       # Needed for PyPI trusted publishing (optional)

jobs:
  check-for-release:
    name: Check for Release Triggers
    runs-on: ubuntu-latest
    outputs:
      should_release: ${{ steps.check.outputs.should_release }}
      release_type: ${{ steps.check.outputs.release_type }}
      version: ${{ steps.check.outputs.version }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Check commit message for release triggers
        id: check
        run: |
          COMMIT_MSG="${{ github.event.head_commit.message }}"
          echo "Commit message: $COMMIT_MSG"
          
          # Aktuelle Version lesen
          CURRENT_VERSION=$(cat VERSION 2>/dev/null || echo "0.0.0")
          echo "Current version: $CURRENT_VERSION"
          
          # Letzten Git-Tag abrufen
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          LAST_TAG_VERSION=${LAST_TAG#v}
          echo "Last tag version: $LAST_TAG_VERSION"
          
          # HÃ¶chste Version verwenden
          if [[ "$LAST_TAG_VERSION" > "$CURRENT_VERSION" ]]; then
            CURRENT_VERSION="$LAST_TAG_VERSION"
            echo "Using tag version as base: $CURRENT_VERSION"
          fi
          
          # Release-Typ bestimmen basierend auf Commit-Message
          SHOULD_RELEASE="false"
          RELEASE_TYPE=""
          NEW_VERSION=""
          
          # Behandle Merge-Commits speziell
          if [[ "$COMMIT_MSG" =~ ^Merge[[:space:]]pull[[:space:]]request ]]; then
            echo "Merge commit detected, analyzing PR content..."
            # FÃ¼r Merge-Commits: Minor release (neue Features zusammengefÃ¼hrt)
            SHOULD_RELEASE="true"
            RELEASE_TYPE="minor"
            NEW_VERSION=$(echo $CURRENT_VERSION | awk -F. '{print $1"."$2+1".0"}')
          elif [[ "$COMMIT_MSG" =~ ^(feat|feature)(\(.+\))?!: ]] || [[ "$COMMIT_MSG" =~ BREAKING[[:space:]]CHANGE ]]; then
            # Major release (breaking change)
            SHOULD_RELEASE="true"
            RELEASE_TYPE="major"
            NEW_VERSION=$(echo $CURRENT_VERSION | awk -F. '{print $1+1".0.0"}')
          elif [[ "$COMMIT_MSG" =~ ^(feat|feature)(\(.+\))?: ]]; then
            # Minor release (new feature)
            SHOULD_RELEASE="true"
            RELEASE_TYPE="minor"
            NEW_VERSION=$(echo $CURRENT_VERSION | awk -F. '{print $1"."$2+1".0"}')
          elif [[ "$COMMIT_MSG" =~ ^(fix|bugfix)(\(.+\))?: ]]; then
            # Patch release (bug fix)
            SHOULD_RELEASE="true"
            RELEASE_TYPE="patch"
            NEW_VERSION=$(echo $CURRENT_VERSION | awk -F. '{print $1"."$2"."$3+1}')
          elif [[ "$COMMIT_MSG" =~ \[release\] ]]; then
            # Manueller Release-Trigger
            SHOULD_RELEASE="true"
            RELEASE_TYPE="patch"
            NEW_VERSION=$(echo $CURRENT_VERSION | awk -F. '{print $1"."$2"."$3+1}')
          elif [[ "$COMMIT_MSG" =~ \[major\] ]]; then
            SHOULD_RELEASE="true"
            RELEASE_TYPE="major"
            NEW_VERSION=$(echo $CURRENT_VERSION | awk -F. '{print $1+1".0.0"}')
          elif [[ "$COMMIT_MSG" =~ \[minor\] ]]; then
            SHOULD_RELEASE="true"
            RELEASE_TYPE="minor"
            NEW_VERSION=$(echo $CURRENT_VERSION | awk -F. '{print $1"."$2+1".0"}')
          fi
          
          # ÃœberprÃ¼fen ob der berechnete Tag bereits existiert
          if [[ "$SHOULD_RELEASE" == "true" ]] && git rev-parse "v$NEW_VERSION" >/dev/null 2>&1; then
            echo "Tag v$NEW_VERSION already exists, skipping release"
            SHOULD_RELEASE="false"
          fi
          
          echo "should_release=$SHOULD_RELEASE" >> $GITHUB_OUTPUT
          echo "release_type=$RELEASE_TYPE" >> $GITHUB_OUTPUT
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          
          echo "Should release: $SHOULD_RELEASE"
          echo "Release type: $RELEASE_TYPE"
          echo "New version: $NEW_VERSION"

  create-release:
    name: Create Automatic Release
    needs: check-for-release
    runs-on: ubuntu-latest
    if: needs.check-for-release.outputs.should_release == 'true'
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Configure Git
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

      - name: Update version files
        run: |
          NEW_VERSION="${{ needs.check-for-release.outputs.version }}"
          
          # VERSION-Datei aktualisieren
          echo "$NEW_VERSION" > VERSION
          
          # __version__.py aktualisieren
          cat > __version__.py << EOF
          #!/usr/bin/env python3
          # -*- coding: utf-8 -*-
          """
          Version information for Bash-Script-Maker
          """
          
          __version__ = "$NEW_VERSION"
          __version_info__ = ($(echo $NEW_VERSION | sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*/\1, \2, \3/'))
          EOF
          
          # pyproject.toml aktualisieren
          sed -i "s/^version = .*/version = \"$NEW_VERSION\"/" pyproject.toml

      - name: Generate release notes and update CHANGELOG
        id: release_notes
        run: |
          NEW_VERSION="${{ needs.check-for-release.outputs.version }}"
          RELEASE_TYPE="${{ needs.check-for-release.outputs.release_type }}"
          COMMIT_MSG="${{ github.event.head_commit.message }}"
          CURRENT_DATE=$(date '+%Y-%m-%d')
          
          # Basis Release-Notes erstellen
          cat > release_notes.txt << EOF
          ## Version $NEW_VERSION
          
          **Release-Typ:** $RELEASE_TYPE
          
          ### Ã„nderungen
          
          $COMMIT_MSG
          
          ### Installation
          
          \`\`\`bash
          # Via pip
          pip install bash-script-maker==$NEW_VERSION
          
          # Aus Quellcode
          git clone https://github.com/securebitsorg/bash-script-maker.git
          cd bash-script-maker
          git checkout v$NEW_VERSION
          ./install.sh
          \`\`\`
          
          ### Artefakte
          
          - Python Wheel (.whl)
          - Source Distribution (.tar.gz)
          - Docker Image (ghcr.io)
          - VollstÃ¤ndiger Quellcode
          EOF
          
          # CHANGELOG.md automatisch aktualisieren
          echo "ðŸ“ Aktualisiere CHANGELOG.md..."
          
          # Backup der aktuellen CHANGELOG erstellen
          cp CHANGELOG.md CHANGELOG.md.bak
          
          # Neue CHANGELOG-EintrÃ¤ge basierend auf Commit-Message generieren
          NEW_CHANGELOG_ENTRY=""
          
          # Ã„nderungen aus Commit-Message extrahieren und kategorisieren
          if [[ "$COMMIT_MSG" =~ ^(feat|feature)(\(.+\))?: ]]; then
            NEW_CHANGELOG_ENTRY="### Added
          - $(echo "$COMMIT_MSG" | sed 's/^[^:]*: //')"
          elif [[ "$COMMIT_MSG" =~ ^(fix|bugfix)(\(.+\))?: ]]; then
            NEW_CHANGELOG_ENTRY="### Fixed
          - $(echo "$COMMIT_MSG" | sed 's/^[^:]*: //')"
          elif [[ "$COMMIT_MSG" =~ ^(docs|doc)(\(.+\))?: ]]; then
            NEW_CHANGELOG_ENTRY="### Documentation
          - $(echo "$COMMIT_MSG" | sed 's/^[^:]*: //')"
          elif [[ "$COMMIT_MSG" =~ ^(style|refactor)(\(.+\))?: ]]; then
            NEW_CHANGELOG_ENTRY="### Changed
          - $(echo "$COMMIT_MSG" | sed 's/^[^:]*: //')"
          elif [[ "$COMMIT_MSG" =~ ^(test|tests)(\(.+\))?: ]]; then
            NEW_CHANGELOG_ENTRY="### Testing
          - $(echo "$COMMIT_MSG" | sed 's/^[^:]*: //')"
          elif [[ "$COMMIT_MSG" =~ ^Merge[[:space:]]pull[[:space:]]request ]]; then
            # FÃ¼r Merge-Commits: PR-Titel extrahieren
            PR_TITLE=$(echo "$COMMIT_MSG" | grep -o 'Merge pull request #[0-9]* from .*/.*' | sed 's/.*\///')
            NEW_CHANGELOG_ENTRY="### Added
          - $PR_TITLE (Pull Request merged)"
          else
            NEW_CHANGELOG_ENTRY="### Changed
          - $COMMIT_MSG"
          fi
          
          # Neue CHANGELOG mit Version am Anfang erstellen
          cat > CHANGELOG.md << EOF
          ## [$NEW_VERSION] - $CURRENT_DATE
          
          $NEW_CHANGELOG_ENTRY
          
          EOF
          
          # Rest der CHANGELOG (ab Zeile 8) anhÃ¤ngen, aber erste automatische EintrÃ¤ge Ã¼berspringen
          sed -n '8,$p' CHANGELOG.md.bak >> CHANGELOG.md
          
          echo "âœ… CHANGELOG.md erfolgreich aktualisiert mit Version $NEW_VERSION"
          
          # ÃœberprÃ¼fung der CHANGELOG-Struktur
          echo "ðŸ“‹ Neue CHANGELOG-Struktur:"
          head -15 CHANGELOG.md
          
          echo "Release-Notes erstellt fÃ¼r Version $NEW_VERSION"

      - name: Commit version changes
        run: |
          NEW_VERSION="${{ needs.check-for-release.outputs.version }}"
          git add VERSION __version__.py pyproject.toml CHANGELOG.md
          git commit -m "chore: bump version to $NEW_VERSION and update CHANGELOG [skip ci]"

      - name: Create and push tag
        run: |
          NEW_VERSION="${{ needs.check-for-release.outputs.version }}"
          
          # ÃœberprÃ¼fen ob Tag bereits existiert
          if git rev-parse "v$NEW_VERSION" >/dev/null 2>&1; then
            echo "Tag v$NEW_VERSION already exists, skipping tag creation"
            exit 0
          fi
          
          # Tag erstellen und pushen (ohne main-Branch zu berÃ¼hren)
          git tag -a "v$NEW_VERSION" -m "Automatic release v$NEW_VERSION"
          echo "Pushing tag v$NEW_VERSION (no main branch push needed)"
          git push origin "v$NEW_VERSION"

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ needs.check-for-release.outputs.version }}
          name: Release ${{ needs.check-for-release.outputs.version }}
          body_path: release_notes.txt
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  build-and-upload:
    name: Build and Upload Assets
    needs: [check-for-release, create-release]
    runs-on: ubuntu-latest
    if: needs.check-for-release.outputs.should_release == 'true'
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: v${{ needs.check-for-release.outputs.version }}

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install build dependencies
        run: |
          python -m pip install --upgrade pip
          pip install twine wheel setuptools

      - name: Build Python packages
        run: |
          python setup.py sdist bdist_wheel

      - name: Create source archive
        run: |
          VERSION=${{ needs.check-for-release.outputs.version }}
          git archive --format=tar.gz --prefix=bash-script-maker-$VERSION/ HEAD > bash-script-maker-$VERSION-source.tar.gz

      - name: Upload to release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ needs.check-for-release.outputs.version }}
          files: |
            dist/*.whl
            dist/*.tar.gz
            bash-script-maker-${{ needs.check-for-release.outputs.version }}-source.tar.gz
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}


  publish-pypi:
    name: Publish to PyPI
    needs: [check-for-release, build-and-upload]
    runs-on: ubuntu-latest
    if: needs.check-for-release.outputs.should_release == 'true' && !contains(needs.check-for-release.outputs.version, '-')
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: v${{ needs.check-for-release.outputs.version }}

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install build dependencies
        run: |
          python -m pip install --upgrade pip
          pip install twine wheel setuptools

      - name: Build packages
        run: python setup.py sdist bdist_wheel

      - name: Publish to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          password: ${{ secrets.PYPI_API_TOKEN }}
          skip-existing: true

  publish-github-packages:
    name: Publish to GitHub Packages
    needs: [check-for-release, build-and-upload]
    runs-on: ubuntu-latest
    if: needs.check-for-release.outputs.should_release == 'true'
    permissions:
      contents: read
      packages: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: v${{ needs.check-for-release.outputs.version }}

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3


      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository_owner }}/bash-script-maker
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}},value=v${{ needs.check-for-release.outputs.version }}
            type=semver,pattern={{major}}.{{minor}},value=v${{ needs.check-for-release.outputs.version }}
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
